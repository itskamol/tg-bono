import { Scene, SceneEnter, On, Message, Action, Ctx } from 'nestjs-telegraf';
import { Markup } from 'telegraf';
import { PrismaService } from '../../prisma/prisma.service';
import { Context } from '../../interfaces/context.interface';
import { safeEditMessageText, safeReplyOrEdit } from 'src/utils/telegram.utils';

interface AddCategorySceneState {
    name?: string;
    awaitingName?: boolean;
}

@Scene('add-category-scene')
export class AddCategoryScene {
    constructor(private readonly prisma: PrismaService) { }

    @SceneEnter()
    async onSceneEnter(@Ctx() ctx: Context) {
        const sceneState = ctx.scene.state as AddCategorySceneState;
        sceneState.awaitingName = true;

        await safeReplyOrEdit(
            ctx,
            "üì¶ <b>Yangi kategoriya qo'shish</b>\n\nüìù Kategoriya nomini kiriting:",
            Markup.inlineKeyboard([
                Markup.button.callback('‚ùå Bekor qilish', 'CANCEL_ADD_CATEGORY'),
            ]),
        );
    }

    @On('text')
    async onText(@Ctx() ctx: Context, @Message('text') text: string) {
        const sceneState = ctx.scene.state as AddCategorySceneState;

        // Kategoriya nomi
        if (sceneState.awaitingName) {
            const trimmedName = text.trim();

            if (trimmedName.length < 2) {
                await safeReplyOrEdit(ctx, "‚ùå Kategoriya nomi kamida 2 ta belgidan iborat bo'lishi kerak.");
                return;
            }

            if (trimmedName.length > 30) {
                await safeReplyOrEdit(ctx, "‚ùå Kategoriya nomi 30 ta belgidan ko'p bo'lmasligi kerak.");
                return;
            }

            // Kategoriya nomi mavjudligini tekshirish
            const existingCategory = await this.prisma.category.findFirst({
                where: { name: { equals: trimmedName, mode: 'insensitive' } },
            });

            if (existingCategory) {
                await safeReplyOrEdit(
                    ctx,
                    '‚ùå Bu nom bilan kategoriya allaqachon mavjud. Boshqa nom kiriting:',
                );
                return;
            }

            sceneState.name = trimmedName;
            sceneState.awaitingName = false;

            // Tasdiqlash
            await safeReplyOrEdit(
                ctx,
                `üìã <b>Yangi kategoriya ma'lumotlari:</b>\n\nüìù <b>Nomi:</b> ${trimmedName}\n\nTasdiqlaysizmi?`,
                Markup.inlineKeyboard(
                    [
                        Markup.button.callback("‚úÖ Ha, qo'shish", 'CONFIRM_ADD_CATEGORY'),
                        Markup.button.callback('üîô Orqaga', 'BACK_TO_NAME'),
                        Markup.button.callback('‚ùå Bekor qilish', 'CANCEL_ADD_CATEGORY'),
                    ],
                    { columns: 1 },
                ),
            );
            return;
        }
    }

    @Action('BACK_TO_NAME')
    async onBackToName(@Ctx() ctx: Context) {
        const sceneState = ctx.scene.state as AddCategorySceneState;
        sceneState.awaitingName = true;
        sceneState.name = undefined;

        await safeEditMessageText(
            ctx,
            "üì¶ <b>Yangi kategoriya qo'shish</b>\n\nüìù Kategoriya nomini kiriting:",
            Markup.inlineKeyboard([
                Markup.button.callback('‚ùå Bekor qilish', 'CANCEL_ADD_CATEGORY'),
            ]),
        );
    }

    @Action('CONFIRM_ADD_CATEGORY')
    async onConfirmAddCategory(@Ctx() ctx: Context) {
        const sceneState = ctx.scene.state as AddCategorySceneState;

        if (!sceneState.name) {
            await safeEditMessageText(ctx, "‚ùå Ma'lumotlar noto'g'ri.");
            await ctx.scene.leave();
            return;
        }

        try {
            const newCategory = await this.prisma.category.create({
                data: {
                    name: sceneState.name,
                },
            });

            await safeEditMessageText(
                ctx,
                `‚úÖ <b>Yangi kategoriya muvaffaqiyatli qo'shildi!</b>\n\nüìù <b>Nomi:</b> ${newCategory.name}`,
            );
            await ctx.scene.leave();
        } catch (error) {
            let errorMessage = "‚ùå Kategoriya qo'shishda xatolik yuz berdi.";

            if (error instanceof Error) {
                if (error.message.includes('duplicate')) {
                    errorMessage = '‚ùå Bu nom bilan kategoriya allaqachon mavjud.';
                } else if (error.message.includes('validation')) {
                    errorMessage = "‚ùå Ma'lumotlar noto'g'ri.";
                }
            }

            await safeEditMessageText(
                ctx,
                `${errorMessage}\n\nQaytadan urinib ko'ring.`,
                Markup.inlineKeyboard([
                    Markup.button.callback('üîÑ Qaytadan', 'RETRY_ADD_CATEGORY'),
                    Markup.button.callback('‚ùå Bekor qilish', 'CANCEL_ADD_CATEGORY'),
                ]),
            );
        }
    }

    @Action('RETRY_ADD_CATEGORY')
    async onRetryAddCategory(@Ctx() ctx: Context) {
        const sceneState = ctx.scene.state as AddCategorySceneState;
        sceneState.awaitingName = true;
        sceneState.name = undefined;

        await safeEditMessageText(
            ctx,
            "üì¶ <b>Yangi kategoriya qo'shish</b>\n\nüìù Kategoriya nomini kiriting:",
            Markup.inlineKeyboard([
                Markup.button.callback('‚ùå Bekor qilish', 'CANCEL_ADD_CATEGORY'),
            ]),
        );
    }

    @Action('CANCEL_ADD_CATEGORY')
    async onCancelAddCategory(@Ctx() ctx: Context) {
        await safeEditMessageText(ctx, "‚ùå Kategoriya qo'shish bekor qilindi.");
        await ctx.scene.leave();
    }
}
